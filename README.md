# Ответы на вопросы по JavaScript и TypeScript для собеседования

## 1. Что такое «строгий режим»? Для чего он нужен?
"Строгий режим" (strict mode) в JavaScript - это способ добровольно использовать более строгую версию языка. Он активируется добавлением директивы `"use strict";` в начале скрипта или функции.

Основные цели строгого режима:
- Предотвращение случайного создания глобальных переменных
- Генерация ошибок в случаях, которые раньше молча игнорировались
- Запрет использования некоторых небезопасных возможностей языка
- Улучшение оптимизации кода движком JavaScript

## 2. Переменные – в чем отличие var, let, const? Когда и что предпочтительнее применять?
- `var`: 
  - Функциональная область видимости
  - Поднимается (hoisting)
  - Может быть повторно объявлена в той же области видимости

- `let`: 
  - Блочная область видимости
  - Не поднимается
  - Нельзя повторно объявить в той же области видимости
  - Можно переприсваивать значение

- `const`: 
  - Блочная область видимости
  - Не поднимается
  - Нельзя повторно объявить в той же области видимости
  - Нельзя переприсваивать значение (но можно менять содержимое объектов и массивов)

Предпочтительное использование:
- `const` для неизменяемых значений (по умолчанию)
- `let` для изменяемых переменных
- Избегать использования `var` в современном коде

## 3. Операторы сравнения
а) В чем отличие `==` от `===`; `!=` от `!==`?
- `==` и `!=` выполняют приведение типов перед сравнением
- `===` и `!==` сравнивают без приведения типов (строгое равенство)

б) Что будет в результате: '01' == 1 и '01' === 1? Почему?
- `'01' == 1` вернёт `true`, потому что `==` выполняет приведение типов
- `'01' === 1` вернёт `false`, потому что `===` сравнивает без приведения типов

в) Что будет в результате: null === undefined и null == undefined? Почему?
- `null === undefined` вернёт `false`, так как это разные типы
- `null == undefined` вернёт `true`, это специальное правило в JavaScript

г) Что будет в результате: null > 0; null == 0; null >= 0? Почему?
- `null > 0` вернёт `false` (null преобразуется в 0)
- `null == 0` вернёт `false` (специальное правило сравнения)
- `null >= 0` вернёт `true` (null преобразуется в 0)

д) Что будет в результате: undefined > 0; undefined < 0; undefined == 0? Почему?
- `undefined > 0` вернёт `false` (undefined преобразуется в NaN)
- `undefined < 0` вернёт `false` (undefined преобразуется в NaN)
- `undefined == 0` вернёт `false` (специальное правило сравнения)

## 4. Функции: можно ли сохранить функцию в переменную?
Да, в JavaScript функции являются объектами первого класса и могут быть сохранены в переменную:

```javascript
const myFunction = function() {
  console.log("Hello, world!");
};

// Или с использованием стрелочной функции:
const myArrowFunction = () => {
  console.log("Hello, world!");
};
```

## 5. Функции колбэки
Пример функции с колбеками для подтверждения действия:

```javascript
function confirmAction(question, onConfirm, onReject) {
  const userResponse = prompt(question);
  if (userResponse && userResponse.toLowerCase() === 'да') {
    onConfirm();
  } else {
    onReject();
  }
}

// Использование:
confirmAction(
  "Вы точно хотите удалить этот элемент?",
  () => console.log("Элемент удален"),
  () => console.log("Операция отменена")
);
```

## 6. Объекты, методы объектов, this
`this` - это ключевое слово, которое ссылается на контекст выполнения функции.

Пример потери `this`:
```javascript
const obj = {
  name: "John",
  greet: function() {
    console.log("Hello, " + this.name);
  }
};

const greet = obj.greet;
greet(); // "Hello, undefined" - потеря контекста
```

Решение через привязку контекста:
```javascript
const boundGreet = obj.greet.bind(obj);
boundGreet(); // "Hello, John"
```

Решение через стрелочную функцию:
```javascript
const obj = {
  name: "John",
  greet: () => {
    console.log("Hello, " + this.name);
  }
};
```

## 7. Планирование: setTimeout и setInterval
- `setTimeout` используется для выполнения функции один раз после заданной задержки
- `setInterval` используется для периодического выполнения функции с заданным интервалом

Отличие `setInterval` от рекурсивного `setTimeout`:
- `setInterval` выполняется строго через заданные промежутки времени, игнорируя время выполнения функции
- Рекурсивный `setTimeout` учитывает время выполнения функции, обеспечивая более точные интервалы

Отмена:
- `clearTimeout(timeoutId)` для отмены setTimeout
- `clearInterval(intervalId)` для отмены setInterval

## 8. Что такое TypeScript? Для чего введен? В чем отличие от JS?
TypeScript - это типизированное надмножество JavaScript, которое компилируется в чистый JavaScript.

Введен для:
- Добавления статической типизации
- Улучшения читаемости и поддерживаемости кода
- Обнаружения ошибок на этапе компиляции
- Поддержки современных возможностей JavaScript

Отличия от JS:
- Статическая типизация
- Поддержка интерфейсов и классов (до их появления в JS)
- Генерики
- Декораторы
- Улучшенная поддержка модулей

## 9. Базовые типы TypeScript
- `number`: числа (целые и с плавающей точкой)
- `string`: строки
- `boolean`: логические значения (true/false)
- `array`: массивы (например, `number[]` или `Array<number>`)
- `tuple`: кортежи (фиксированные массивы с элементами разных типов)
- `enum`: перечисления
- `any`: любой тип
- `void`: отсутствие возвращаемого значения
- `null` и `undefined`
- `never`: тип, который никогда не должен возникнуть
- `object`: нечисловой, нестроковый, небулевый тип

## 10. Обобщенные типы (generics) в TypeScript
Обобщенные типы позволяют создавать компоненты, работающие с различными типами данных.

Пример функции с обобщенным типом:
```typescript
function identity<T>(arg: T): T {
  return arg;
}

let output = identity<string>("myString");
```

Пример интерфейса с обобщенным типом:
```typescript
interface GenericInterface<T> {
  (arg: T): T;
}

function identity<T>(arg: T): T {
  return arg;
}

let myIdentity: GenericInterface<number> = identity;
```

## 11. Типы (type) и интерфейсы (interface) в TypeScript, в чем их отличие?
Основные отличия:
- Интерфейсы могут быть расширены, типы - нет (но могут использовать пересечения)
- Типы могут представлять примитивы, объединения, кортежи и другие расширенные типы
- Интерфейсы лучше подходят для описания структуры объектов
- Типы могут создавать псевдонимы для сложных типов

```typescript
// Интерфейс
interface User {
  name: string;
  age: number;
}

// Тип
type UserType = {
  name: string;
  age: number;
};
```

## 12. Как сделать ряд свойств интерфейса необязательными? Как сделать все свойства интерфейса необязательными?
Для отдельных свойств:
```typescript
interface User {
  name: string;
  age?: number; // Необязательное свойство
}
```

Для всех свойств:
```typescript
type Optional<T> = {
  [P in keyof T]?: T[P];
};

interface User {
  name: string;
  age: number;
}

type OptionalUser = Optional<User>;
```

## 13. Для чего нужен тип "Omit" в TypeScript?
Тип `Omit` используется для создания нового типа путем исключения определенных свойств из существующего типа:

```typescript
interface User {
  name: string;
  age: number;
  email: string;
}

type UserWithoutEmail = Omit<User, 'email'>;
// Результат: { name: string; age: number; }
```

## 14. Возможно ли в TypeScript перегрузить функцию?
Да, в TypeScript возможна перегрузка функций:

```typescript
function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: any, b: any): any {
  return a + b;
}

console.log(add(1, 2)); // 3
console.log(add("Hello, ", "world!")); // "Hello, world!"
```


 
